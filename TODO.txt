Create Collection class. Rewrite MACRO-APE to use this class.

Create CLI-apps:
-- to split file on motifs to save them in separate files
-- to merge many files(or whole folder) to a Collection
-- to transform pcm --> pwm for a single file 
    pcm2pwm in.pcm out.pwm
    pcm2pwm in_folder out_folder
    pcm2pwm in1.pcm in2.pcm in3.pcm  (will automatically create files with *.pwm extension in the same folder)

Make Parsers to be switcheable in runtime so that one could parse string composed of two motifs in different formats.

Simplify   PM.choose_parser(input).new(input) --> Parser.choose(input [, PM] )

Make parser to parse strings:
-- with `A C G T` header (such as pretty_print makes)
-- with A, C, G, T  row-names (transposed pretty_print)

Make output to letters-as-rows format. Make sure that in normally parses 4x4 matrices dependent on ACGT in rows or in columns

Decide:
-- Whether PPM should have `words_count`/`weight`?
   PPM format such that parser got both matrix and count (if PPM have `word_count`)
-- shall one redo has_all_keys? with use of Set#&
-- can_parse?
-- Whether to cache suffices:  cache :best_suffix, obsolete: [:discrete!, :background!, ...]

Specs
-- PM#==  (!)
-- Hash#has_one_key?  in case when argument have repeating keys. Should has_one_key? return true or false?
-- PWM#probabilities, #score_variance, #gauss_estimation

May be:

Transform
-- lines.map{|line| line.split.map(&:to_f)} --> lines.map(&:split | &:map.(&:to_f))  -- one should review Matz examples in Programming Ruby book
-- matrix.all?{|line| line.size == 4}  -->   matrix.all?(&:size | :== 4)  --> matrix.all? (&:size | :eq.(4) )
    or simply matrix.all?(&:size.() == 4)  i.e. :size().() - is an object and one can define method_missing-proxy on it

gemify callable_symbol in a library of functional extensions
  (?) def itself;self;end